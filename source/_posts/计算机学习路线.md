---
title: 计算机学习路线
date: 2100-12-29
categories: [方法论]
---
A computer scientist's advices from his [blog](https://www.afternerd.com/blog/learn-computer-science/)
How to Learn Computer Science? (from Zero to Hero)
personal opinions and information through real-world experiences
https://teachyourselfcs.com/
https://bradfieldcs.com/
<!-- more -->
## - *The Coder*
*   Writing code that does the job
*   knows how to speak the language of a machine
*   break down a given problem into instructions that the machine can understand in order to come up with a solution.
*   your skills are *easily* replaceable
*   learned the basics of at least two programming languages (preferably one statically-typed【Java】 and one dynamically-typed【Python】)⇒take you from an absolute beginner to a professional Pythonista
    *   the difference between statically and dynamically
    *   To learn python, highly recommend [https://book.douban.com/subject/31333701/](https://book.douban.com/subject/31333701/)
    *   Java。teach you some programming concepts that don’t even exist in Python.
        *   Java fundamentals [https://book.douban.com/subject/30326049/](https://book.douban.com/subject/30326049/)
        *   advanced Java features [https://book.douban.com/subject/30403780/](https://book.douban.com/subject/30403780/)
        *   not to overwhelm yourself with the advanced features for now. Focus on the fundamentals in this phase.
    *   combination ⇒ a very solid idea of the programming concepts that you will need in almost any other programming language。
## - *The Programmer*
*   a *sophisticated coder*.
*   writing *efficient* code that does the job
*   There is still a long way to go on your career path.There are a lot of coders out there.The vast majority of software engineers retire at this phase.
*   understand what makes code efficient and what doesn’t
*   understand that quality is important and that testing your code is crucial.
*   understand how hardware is eventually going to run your code.know the fundamentals of how any code eventually turns into something that a hardware chip can understand and execute.understand that any system has finite compute, storage, and network resources and your software should utilize these resources efficiently.You know that you have limited hardware resources and you understand the value of utilizing the available resources efficiently.
*   know how to use data structures and algorithms to write efficient code。Studying algorithms and data structures will teach you how to write code in a way that makes your code more efficient, however you define efficiency. it could be speed, resource utilization, or both.
*   expect to get an entry-level job at any of the big tech companies
*   you can easily secure a job at one of the big tech companies like Google, Facebook, Amazon, and others.
*   most of the interviews conducted at these companies test how good of a *programmer, not how good of a coder
*   [https://www.afternerd.com/blog/coding-interview/](https://www.afternerd.com/blog/coding-interview/)
## - *The Computer Scientist*
*   an architect who thinks about the big picture more than the nitty gritty details
*   have a solid understanding of designing large distributed systems
*   know how to build scalable systems that can handle large loads and tolerate failures
*   always tries to stay up to date with the latest in technology
*   be in charge of big projects
*   managing a team (usually of coders and solid programmers) to get the job done
*   cooperate with other teams
*   stellar social and leadership skills
## - Programming
*   The first and only step is to learn programming.
*   it gives you a quick feedback about whether you should pursue a CS career or not.
*   concepts will hold true in almost any other programming language⇒each a point where learning a new programming language doesn’t take more than a week⇒ develop significant projects.
*   [https://www.afternerd.com/blog/learn-python/](https://www.afternerd.com/blog/learn-python/)
*   [*Python Crash Course.*](https://amzn.to/2WAVGIV)
## - The Software Stack
*   What does variable assignment (**x = 5**) mean at the hardware level?
*   What is  **x,** really?
*   How is the number 5 represented in hardware?
*   How does addition actually happen?
*   And how did the result end up on my screen?!!
*   At the end of the day, a computer is just a collection of hardware chips and wires.
*   How can a computer really understand your code? and execute it flawlessly?
*   your code is just the tip of the iceberg. There are a lot of other layers under your code. Together, they make the whole thing work the way you expect it to work.
*   A *programmer* unravels this magic.
*   At this level, you need a solid understanding of all the layers of the stack starting from your code, all the way down to the hardware layer.
## - Algorithms and Data Structures
*   [The Elements of Computing Systems](https://amzn.to/2TayqAG) by [Noam Nisan](http://www.cs.huji.ac.il/~noam/) and [Shimon Schocken](http://shimonschocken.com/) is unequivocally my top suggestion for a book that will teach you the essential information you need to understand each layer of the stack. [https://book.douban.com/subject/1998645/](https://book.douban.com/subject/1998645/)
    *   The book covers hardware, compilers, linkers, and operating systems at a very basic level which makes it very beginner friendly.
    *   It walks you through the steps of creating your first programming language, creating a compiler and a linker for it, and then creating an operating system.
    * *   When it comes to algorithms and data structures
*   unequivocally [https://book.douban.com/subject/20432061/](https://book.douban.com/subject/20432061/)
*   [https://book.douban.com/subject/1610337/](https://book.douban.com/subject/1610337/) Data Structures and Algorithms in Java
*   [https://book.douban.com/subject/21325184/](https://book.douban.com/subject/21325184/) Problem Solving with Algorithms and Data Structures Using Python SECOND EDITION
*   Be aware that the topic of data structures and algorithms is language neutral, so it doesn’t matter which programming language you’re using.
*   In fact, most big tech companies like Google, Facebook, and Amazon [focus a lot on data structures questions during their interview process](https://www.careercup.com/page)
## - Networks
*   code communicates with other computers either in a local network or the internet.
*   Programmers need to have a very solid foundation of how computer networking works.
*   It helped me overcome the dry text book that my professor at the time recommended.
*   [Computer Networking: A Top-Down Approach](https://book.douban.com/subject/30280001/) by [Kurose](https://www.cics.umass.edu/faculty/directory/kurose_james) and [Ross](http://engineering.nyu.edu/people/keith-w-ross) is a very well-written, super easy to understand book that covers all the networking basics that you need to know.
*   I still go back to this book every now and then if I need a refresher.
## - Operating Systems
*   Operating systems play a major role in the software stack.
*   have a very broad idea of the role of an operating system in the stack.
*   But now is the time to have a deeper understanding of operating systems.
*   [Operating Systems Concepts](https://amzn.to/2S0QBeF) by [Abraham Silberschatz](http://codex.cs.yale.edu/avi/) is one of the best books on the [subject.https://book.douban.com/subject/10076960/](subject.https://book.douban.com/subject/10076960/)
    *   You need some basic knowledge of C though, because the majority of operating systems are written in C.
    *   My recommendation, unless you want to be a kernel developer,  is not to allow yourself to get stuck at this point.
    *   This is a very dense topic. Understanding all the details of all the aspects of operating systems is very time consuming.
    *   Grasping the main fundamental operating systems concepts is good enough to keep you going but don’t get bogged down in details.
*   Another resource I highly recommend is the [OSDev Wiki](https://wiki.osdev.org/), especially if you want to learn how to create your own kernel. This is pretty advanced, but it’s something that the vast majority of software engineers can’t do.
*   *Look at that! You’ve achieved the status of programmer!*
## - Distributed Systems
*   Welcome to the start of your *computer scientist* status.
*   In this level, you will be learning new skills while you improve the skills you learned as a *programmer*.
*   Distributed systems is about building and architecting software systems that are 【scalable and that can tolerate failures】 at the same time. This requires you to think of the 【bigger picture】, rather than focusing on how to build the individual components–programmers and coders can do that.
*   For example, think about building a search engine service, like Google, for some text files that exist only in your laptop.
*   This service will listen to search queries that it receives over the network, search your files for the query, and respond with the results.
*   This is not a hard thing to do. Any *programmer *with a decent knowledge of algorithms and data structures can build an efficient search engine for a small number of files.
*   Now imagine that more and more people become interested in your service and they start using it.
*   Now you’re getting millions and millions of requests a second.
*   Not only that, but the size and number of files you are searching through begins to grow dramatically.
*   What happens if your laptop (that hosts the search service) fails?
*   Will you just ignore the millions of requests you’re getting?
*   Distributed systems is about creating 【an army of computers】 that work together to form a specific task (in our example, the search service).
*   It allows you to create scalable systems that can 【handle more requests or more data】. At the same time, it provides redundancy that would be useful in case any one (or more) machine fails.
*   Now, let’s talk about resources.
*   By far, [this blog post](http://the-paper-trail.org/blog/distributed-systems-theory-for-the-distributed-systems-engineer/) is the best resource I have found on the subject (disclaimer: you will need to read some academic papers).
*   If you are a text book kind of person, then this [O’Reilly book](https://book.douban.com/subject/26197294/) by [Martin Kleppmann](https://martin.kleppmann.com/) is excellent. I have skimmed through it, and it covers most of the important topics.
*   With that said, Distributed Systems is a field where experience matters a lot.
*   learn the theory
*   working on distributed systems projects.
## - Machine Learning
*   Machine learning is an interdisciplinary field that spans computer science, mathematics, and statistics.
*   [Netflix uses it for movie recommendations](http://www.wired.co.uk/article/how-do-netflixs-algorithms-work-machine-learning-helps-to-predict-what-viewers-will-like),
*   [Amazon uses it for their recommendation engine and for Amazon Echo](https://aws.amazon.com/machine-learning/),
*   [Vesty Waves uses it to automatically classify articles](http://www.vestywaves.com/)
*   [the list goes on](https://www.wordstream.com/blog/ws/2017/07/28/machine-learning-applications).
*   To be able to build these types of software, you need to be more than just a solid programmer because as I mentioned this field requires a very strong mathematical and statistical foundation.
*   And **no**, learning everything about Python’s [Scikit-Learn](https://machinelearningmastery.com/a-gentle-introduction-to-scikit-learn-a-python-machine-learning-library/) library (a very popular Python library for machine learning) won’t make you a data scientist or a machine learning expert. You still need to understand the mathematical and statistical underpinnings.
*   There are two ways to study machine learning: the top-down approach method, where you start first by writing machine learning code right away (for example ,by using Python’s Scikit-Learn library) and understand the math later, or the bottom-up approach, where you start with the math first and then move up to coding.
*   I personally prefer the second method, just because that’s what works best for me. Even though It’s harder to start and takes longer before you start writing code, once you grasp the concepts, learning how to use a machine learning library is going to be a piece of cake.
*   On the other hand, the top-down approach has the advantage of allowing you to begin writing machine-learning code fast.
*   This motivates a lot of people.
*   The downside of the top-down approach is that it will be much harder for you to understand why some techniques work, while others don’t, because you won’t have the necessary mathematical background at first.
*   [Andrew Ng’s course](https://www.coursera.org/learn/machine-learning) on Coursera is a very good place to start.
*   If you have prior knowledge of mathematics, probability, and statistics, then [An Introduction to Statistical Learning](https://book.douban.com/subject/21706191/) is a very good book for building the statistical and mathematical foundations for machine learning.
*   However, don’t use this book if you aren’t already strong in linear algebra, probabilities, and basic statistics because you will not be able to understand it.
*   If you want to solve real world problems and make money doing this, then create a team, go to [Kaggle](https://www.kaggle.com/competitions), solve a problem, and make some money.
*   *You did it! You can now call yourself a computer scientist!*
