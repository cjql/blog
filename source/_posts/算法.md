---
title: 算法
tags: [mind,wiki,fix]
---
算法百科
<!-- more -->
数据结构与算法的关系:相互依赖不可分割的.
算法的定义:算法是解决特定问题求解步骤的描述,在计算机中为指令的有限序列,并且每条指令表示一个或多个操作。
算法的特性:有穷性、确定性、可行性、输入、输出。
算法的设计的要求:正确性、可读性、健壮性、高效率和低存储量需求。
算法特性与算法设计容易混,需要对比记忆。
算法的度量方法:事后统计方法(不科学、不准确)、事前分析估算方法。
在讲解如何用事前分析估算方法之前,我们先给出了函数渐近增长的定义。
# 函数的渐近增长
给定两个函数f(n)和g(n),
如果存在一个整数N,使得对于所有的n>N,f(n)总是比g(n)大,那么,我们说fn)的增长渐近快于g(n)。
于是我们可以得出一个结论,判断一个算法好不好,我们只迪过少量的数据是不能做出准确判断的
对比算法的关键执行次数函数的渐近增长性,基本就可以分析出:某个算法,随着n的变大,它会越来越优于另一算法,或者越来越差于另一算法。
算法时间复杂度的定义

#推导大O阶的步骤
>用常数1取代运行时间中的所有加法常数。  
 在修改后的运行次数函数中,只保留最高阶项。  
 如果最高阶项存在且不是1,则去除与这个项相乘的常数。 

得到的结果就是大0阶。  
在得到算法的运行次数表达式后,很快得到它的时间复杂度,即大0阶。
推导大0阶很容易,但如何得到运行次数的表达式却是需要数学功底的。
# 常见的时间复杂度所耗时间的大小排列
O(1)<O(logn)<O(n)<O(nlogn)<O(n2)<O(n3)<O(2")<O(n!)<O(n")
算法最坏情况和平均情况
空间复杂度
弄明白算法的时间复杂度的估算
深究自己写的代码是否效率低下,是不是可以通过优化让计算机更加快速高效。
# CPU与算法
现在CPU越来越快,根本不用考虑算法的优劣,实现功能即可,用户感觉不到算法好坏造成的快慢？
<blockquote>假设CPU在短短几年间,速度提高了100倍,这其实已经很夸张了。
而我们的某个算法本可以写出时间复杂度是O(n)的程序,却写出了0(n2)的程序,仅仅因为容易想到,也容易写。
即在O(n2)的时间复杂度算法程序下,速度其实只提高了10(√100=10),而对于0(n)时间复杂度的算法来说,那才是真的100倍。
也就是说,一台老式CPU的计算机运行O(n)的程序和一台速度提高100倍新式CPU运行O(n2)的程序。</blockquote>
最终效率高的胜利方却是老式CPU的计算机,原因就在于算法的优劣直接决定了程序运行的效率。
